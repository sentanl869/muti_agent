"""
统一的 Prompt 管理模块
包含所有 LLM 相关的提示词
"""


class DocumentCheckerPrompts:
    """文档检查器相关的提示词"""
    
    # 内容规范检查提示词
    CONTENT_COMPLIANCE_CHECK = """请根据以下文档规范检查章节内容，找出所有违反规范的地方：

## 文档规范要求：
{rules_text}

## 待检查的章节内容：
{chapter_content}

## 检查要求：
1. 仔细检查章节内容是否违反了上述任何规范
2. 对于每个违规项，请提供：
   - 违反的具体规范
   - 违规的具体内容（引用原文）
   - 违规内容的位置描述
   - 改进建议

## 输出格式：
请按以下格式输出检查结果：

违规项1:
规范: [违反的具体规范]
内容: [违规的具体内容]
位置: [违规内容在章节中的位置]
建议: [具体的改进建议]

违规项2:
...

如果没有发现违规项，请回答"未发现违规项"。

请开始检查："""

    # 图像描述提示词
    IMAGE_DESCRIPTION = """请详细描述这张图片的内容，特别关注以下方面：

1. **图片类型**: 确定这是什么类型的图片（截图、流程图、架构图、数据图表、界面图等）

2. **主要内容**: 描述图片的主要内容和信息

3. **文字信息**: 如果图片中包含文字，请准确识别并记录

4. **图表元素**: 如果是图表，请描述：
   - 标题和标签
   - 坐标轴信息
   - 图例说明
   - 数据内容

5. **技术细节**: 如果是技术图表，请描述：
   - 组件和模块
   - 连接关系
   - 流程步骤
   - 关键信息

6. **规范相关**: 特别注意可能与文档规范相关的内容：
   - 是否有清晰的标题
   - 是否有必要的说明
   - 图片质量是否清晰
   - 信息是否完整

请用中文回答，描述要详细且准确。"""

    # 图像分析默认提示词
    IMAGE_ANALYSIS_DEFAULT = """请详细描述这张图片的内容，特别关注以下方面：
1. 图片类型（截图、图表、流程图、架构图等）
2. 主要内容和信息
3. 文字内容（如果有）
4. 图表元素（标题、标签、图例等）
5. 技术细节和关键信息
请用中文回答，描述要详细且准确。"""

    # 章节标题相似度判断提示词
    CHAPTER_TITLE_SIMILARITY = """请判断以下两个章节标题是否表达相同或相似的含义：

模板标题: {title1}
目标标题: {title2}

## 判断规则：

### 1. 精确匹配
如果两个标题完全相同或仅有微小的格式差异（如空格、标点符号），则判断为"是"。

### 2. 语义匹配
如果两个标题表达相同的概念或主题，即使用词不完全相同，也判断为"是"。

### 3. 泛化标题匹配（核心重点）
**特别重要**：如果模板标题是泛化描述或样本性质的表达，需要采用非常宽松的匹配标准：

#### 3.1 编号类型泛化匹配
- 模板标题包含"模块1"、"模块2"、"模块X"、"组件A"、"系统1"等编号泛化表达
- 目标标题如果是该类别的具体实现，则判断为"是"
- 示例：
  - "4.6.1.3.1.模块1安全设计" ↔ "4.6.1.3.1.用户认证模块安全设计" → "是"
  - "组件A功能说明" ↔ "Redis缓存组件功能说明" → "是"
  - "系统1架构设计" ↔ "用户管理系统架构设计" → "是"

#### 3.2 括号说明类型泛化匹配
- 模板标题包含括号说明，如"(改成具体的...)"、"(根据需要...)"、"(可自行...)"等
- 这类标题明确表示需要替换为具体内容，目标标题如果是相应的具体实现，则判断为"是"
- 示例：
  - "流程1(改成具体的流程名字)" ↔ "用户注册流程" → "是"
  - "功能模块(根据需要可自行添加)" ↔ "支付功能模块" → "是"
  - "接口设计(替换为具体接口名)" ↔ "登录接口设计" → "是"

#### 3.3 斜杠选择类型泛化匹配
- 模板标题包含"/"分隔的多个选项，如"子模块1/类1/主题1"、"方案A/方案B"等
- 目标标题如果匹配其中任何一个概念或相关的具体实现，则判断为"是"
- 示例：
  - "子模块1/类1/主题1" ↔ "用户管理子模块" → "是"
  - "子模块2/类2/主题2" ↔ "数据处理类" → "是"
  - "方案A/方案B/备选方案" ↔ "高可用方案" → "是"

#### 3.4 占位符类型泛化匹配
- 模板标题包含"XX"、"某某"、"具体的"、"相关的"等占位符表达
- 目标标题如果是相应类别的具体实现，则判断为"是"
- 示例：
  - "XX模块设计说明" ↔ "支付模块设计说明" → "是"
  - "某某功能实现" ↔ "登录功能实现" → "是"
  - "具体的安全策略" ↔ "数据加密安全策略" → "是"

#### 3.5 变量类型泛化匹配
- 模板标题使用变量表达，如"流程x"、"步骤N"、"阶段i"等
- 目标标题如果是该变量的具体实例，则判断为"是"
- 示例：
  - "流程x(根据需要可自行添加章节)" ↔ "数据备份流程" → "是"
  - "步骤N详细说明" ↔ "步骤3详细说明" → "是"
  - "第i个模块" ↔ "第二个模块" → "是"

#### 3.6 泛化词汇匹配
- 模板标题包含"组件"、"模块"、"部分"、"系统"、"功能"、"流程"等泛化词汇
- 结合数字、字母或其他标识符时，目标标题如果是该类别的具体实现，则判断为"是"
- 示例：
  - "预使用组件版本合规性" ↔ "第三方组件版本合规性检查" → "是"
  - "数据处理流程" ↔ "用户数据处理流程" → "是"

#### 3.7 可扩展性描述匹配
- 模板标题包含"可自行添加"、"根据需要"、"按需配置"等可扩展性描述
- 目标标题如果是相应的具体扩展实现，则判断为"是"
- 示例：
  - "附加功能(根据需要可自行添加)" ↔ "消息推送功能" → "是"
  - "扩展模块(按需配置)" ↔ "日志记录扩展模块" → "是"

### 4. 结构层级匹配
如果两个标题在文档结构中处于相同层级，且核心概念相同，即使表达方式不同，也应判断为"是"。

### 5. 必做/可选标记处理
标题中的"（必做）"、"（可选）"、"（推荐）"等标记不影响核心内容的匹配判断。

## 泛化标题识别关键词：
在判断时，如果模板标题包含以下任何特征，都应视为泛化标题并采用宽松匹配：
- 编号标识：1、2、3、A、B、C、X、N、i等
- 括号说明：(改成...)、(根据需要...)、(可自行...)、(替换为...)
- 斜杠选择：选项1/选项2、类1/类2、方案A/方案B
- 占位符：XX、某某、具体的、相关的
- 变量表达：x、N、i等数学变量
- 可扩展性：可自行添加、根据需要、按需配置、可选择

## 判断流程：
1. **首先检查模板标题是否包含泛化特征**
2. 如果是泛化标题，采用极度宽松的匹配标准
3. 如果不是泛化标题，检查是否为精确匹配
4. 最后进行严格的语义匹配
5. 考虑结构层级和标记处理

## 输出要求：
请只回答"是"或"否"。

## 核心原则：
**宁可误判为匹配，也不要将泛化标题误判为缺失！** 泛化标题的存在本身就表明模板的灵活性和可扩展性，应该被优先识别和匹配。"""

    # 图像描述分析提示词（用于混合内容分析）
    IMAGE_DESCRIPTION_FOR_MIXED_CONTENT = """请描述图片{image_number}的内容，重点关注与文档规范相关的信息。"""

    # 关键章节检查提示词
    CRITICAL_CHAPTER_CHECK = """请判断以下一到三级章节列表中是否包含与"{required_chapter}"相关的章节：

一到三级章节列表：
{chapter_list}

判断标准：
- 章节标题中包含"{required_chapter}"关键词
- 章节标题表达的概念属于{required_chapter}范畴

请只回答"是"或"否"。"""

    # 批量语义匹配提示词
    BATCH_SEMANTIC_MATCHING = """请分析以下模板章节标题和目标章节标题之间的语义相似度。

## 模板章节标题：
{template_titles}

## 目标章节标题：
{target_titles}

{context_info}

## 匹配规则：

### 1. 泛化标题优先匹配 (0.8-1.0) - 最高优先级
**特别重要**：模板标题如果包含以下泛化特征，必须采用极度宽松的匹配标准：

#### 1.1 编号泛化标识
- 包含：模块1/2/3、组件A/B/C、系统X、流程N、步骤i等
- 示例：T1="模块1设计" vs G2="用户认证模块设计" → 0.9

#### 1.2 括号说明泛化
- 包含：(改成具体的...)、(根据需要...)、(可自行...)、(替换为...)
- 示例：T2="流程1(改成具体的流程名字)" vs G1="用户注册流程" → 0.9

#### 1.3 斜杠选择泛化
- 包含：选项1/选项2、子模块1/类1/主题1、方案A/方案B
- 示例：T3="子模块1/类1/主题1" vs G3="用户管理子模块" → 0.9

#### 1.4 占位符泛化
- 包含：XX、某某、具体的、相关的等占位符
- 示例：T4="XX模块功能说明" vs G4="支付模块功能说明" → 0.9

#### 1.5 变量表达泛化
- 包含：x、N、i等数学变量表达
- 示例：T5="流程x详细描述" vs G5="数据备份流程详细描述" → 0.9

#### 1.6 可扩展性描述泛化
- 包含：可自行添加、根据需要、按需配置、可选择等
- 示例：T6="扩展功能(根据需要可自行添加)" vs G6="消息推送功能" → 0.9

### 2. 精确匹配 (1.0)
- 标题完全相同或仅有微小格式差异（空格、标点符号）

### 3. 高语义相似匹配 (0.8-0.9)
- 表达相同概念，用词略有不同
- 非泛化的样本章节匹配

### 4. 中等相似度匹配 (0.5-0.7)
- 相关概念，但有一定差异
- 同类型章节，具体内容不同

### 5. 低相似度匹配 (0.1-0.4)
- 有一定关联，但差异较大
- 可能存在远程关联

### 6. 无关匹配 (0.0)
- 完全不相关的章节

## 泛化标题识别清单：
在分析每个模板标题时，检查是否包含：
✓ 数字编号：1、2、3、N、i、x
✓ 字母编号：A、B、C、X
✓ 括号说明：(改成...)、(根据需要...)、(可自行...)
✓ 斜杠选择：选项1/选项2、类型A/类型B
✓ 占位符词：XX、某某、具体的、相关的
✓ 可扩展性：可自行添加、根据需要、按需配置
✓ 泛化词汇：模块、组件、系统、流程 + 标识符

## 判断原则：
1. **泛化标题检测优先**：首先识别模板标题是否为泛化类型
2. **宽松匹配策略**：泛化标题采用0.8-0.9的高分匹配
3. **概念类别匹配**：只要目标标题属于相同概念类别即可高分匹配
4. **避免误判缺失**：宁可高分匹配，也不要低分导致缺失误判

## 输出格式：
请按以下格式输出相似度矩阵：

```
SIMILARITY_MATRIX:
T1-G1: 0.9 | 原因：模板标题"模块1"为泛化表达，目标为具体模块实现
T1-G2: 0.2 | 原因：概念不相关
...
T2-G1: 0.1 | 原因：主题不同
T2-G2: 0.9 | 原因：模板标题包含括号说明"(改成具体的...)"，为泛化标题
...
```

## 特别提醒：
**对于任何包含泛化特征的模板标题，都应优先考虑其样本性质，给予0.8-0.9的高分匹配，避免将泛化标题误判为缺失章节！**

请开始分析："""

    # 上下文感知章节匹配提示词
    CONTEXT_AWARE_MATCHING = """请根据上下文信息分析模板章节与候选目标章节的匹配关系。

## 模板章节：
标题: {template_title}
层级: H{template_level}
位置: 第{template_position}个

## 候选目标章节：
{candidate_chapters}

## 上下文信息：
{context_info}

## 匹配策略：

### 1. 泛化标题优先识别（最高优先级）
**首要任务**：检查模板标题是否为泛化表达，如果是，则采用极度宽松的匹配标准：

#### 1.1 泛化特征检测
检查模板标题是否包含：
- 编号标识：模块1/2/X、组件A/B/C、系统N、流程i等
- 括号说明：(改成具体的...)、(根据需要...)、(可自行...)
- 斜杠选择：子模块1/类1/主题1、方案A/方案B
- 占位符：XX、某某、具体的、相关的
- 变量表达：x、N、i等数学变量
- 可扩展性：可自行添加、根据需要、按需配置

#### 1.2 泛化标题匹配规则
如果模板标题包含泛化特征：
- 只要候选章节属于相同概念类别，给予0.85-0.95高分
- 忽略具体名称差异，重点关注功能类别匹配
- 优先考虑层级结构相同的候选章节

### 2. 层级结构匹配
- 优先匹配相同层级（H1-H1, H2-H2）的章节
- 层级匹配的基础分数：0.3

### 3. 位置关系匹配
- 参考上下文中的重编号模式
- 考虑章节在文档中的相对位置
- 位置匹配的基础分数：0.2

### 4. 同级章节映射参考
- 分析已成功映射的同级章节模式
- 推断当前章节的可能映射关系
- 模式一致性加分：0.1-0.2

### 5. 语义内容匹配
- 对于非泛化标题，进行严格的语义匹配
- 对于泛化标题，进行宽松的概念类别匹配
- 语义匹配基础分数：0.4-0.8

## 评分原则：

### 泛化标题评分（0.85-0.95）：
- 确认为泛化标题 + 概念类别匹配 + 层级相同 = 0.95
- 确认为泛化标题 + 概念类别匹配 + 层级相近 = 0.90
- 确认为泛化标题 + 概念相关 + 层级相同 = 0.85

### 非泛化标题评分（0.0-1.0）：
- 精确匹配 = 1.0
- 高语义相似 + 层级匹配 = 0.8-0.9
- 中等相似 + 上下文支持 = 0.6-0.7
- 低相似度 = 0.1-0.4
- 无关 = 0.0

## 特别强调：
1. **泛化标题检测是第一步**，必须优先处理
2. **宁可误判为匹配，也不要将泛化标题误判为缺失**
3. **概念类别比具体名称更重要**（对于泛化标题）
4. **结合上下文模式进行推理**

## 输出格式：
请为每个候选章节给出匹配分数和详细原因：

候选1: [分数] | 原因：[是否为泛化标题] + [匹配类型] + [层级关系] + [具体说明]
候选2: [分数] | 原因：[是否为泛化标题] + [匹配类型] + [层级关系] + [具体说明]
...

## 示例格式：
候选1: 0.90 | 原因：模板标题"流程1(改成具体的流程名字)"为泛化标题，候选章节"用户注册流程"属于流程类别，层级匹配H2
候选2: 0.05 | 原因：非泛化标题，概念不相关，层级不匹配

分数范围：0.0-1.0，1.0表示完全匹配。"""


class PromptBuilder:
    """提示词构建器，用于动态构建提示词"""
    
    @staticmethod
    def build_content_check_prompt(rules_text: str, chapter_content: str) -> str:
        """构建内容检查提示词"""
        return DocumentCheckerPrompts.CONTENT_COMPLIANCE_CHECK.format(
            rules_text=rules_text,
            chapter_content=chapter_content
        )
    
    @staticmethod
    def build_image_description_prompt(image_context: str = None, 
                                     alt_text: str = None, 
                                     title: str = None) -> str:
        """构建图像描述提示词"""
        prompt = DocumentCheckerPrompts.IMAGE_DESCRIPTION
        
        # 添加上下文信息
        if image_context:
            prompt += f"\n\n**图片上下文**: {image_context}"
        
        if alt_text:
            prompt += f"\n\n**图片Alt文本**: {alt_text}"
        
        if title:
            prompt += f"\n\n**图片标题**: {title}"
        
        return prompt
    
    @staticmethod
    def build_title_similarity_prompt(title1: str, title2: str) -> str:
        """构建标题相似度判断提示词"""
        return DocumentCheckerPrompts.CHAPTER_TITLE_SIMILARITY.format(
            title1=title1,
            title2=title2
        )
    
    @staticmethod
    def build_mixed_content_analysis_prompt(base_prompt: str, 
                                          text_content: str, 
                                          image_descriptions: list) -> str:
        """构建混合内容分析提示词"""
        combined_content = f"文本内容:\n{text_content}\n\n"
        
        if image_descriptions:
            combined_content += "图像内容:\n" + "\n\n".join(image_descriptions)
        
        return f"{base_prompt}\n\n内容:\n{combined_content}"
    
    @staticmethod
    def build_critical_chapter_check_prompt(required_chapter: str, chapter_titles: list) -> str:
        """构建关键章节检查提示词"""
        chapter_list = "\n".join([f"- {title}" for title in chapter_titles])
        
        return DocumentCheckerPrompts.CRITICAL_CHAPTER_CHECK.format(
            required_chapter=required_chapter,
            chapter_list=chapter_list
        )
    
    @staticmethod
    def build_batch_semantic_matching_prompt(template_titles: list, target_titles: list, 
                                           context_info: str = "") -> str:
        """构建批量语义匹配提示词"""
        # 格式化模板标题
        template_section = ""
        for i, title in enumerate(template_titles):
            template_section += f"T{i+1}: {title}\n"
        
        # 格式化目标标题
        target_section = ""
        for i, title in enumerate(target_titles):
            target_section += f"G{i+1}: {title}\n"
        
        # 格式化上下文信息
        context_section = ""
        if context_info:
            context_section = f"\n## 上下文信息：\n{context_info}\n"
        
        return DocumentCheckerPrompts.BATCH_SEMANTIC_MATCHING.format(
            template_titles=template_section,
            target_titles=target_section,
            context_info=context_section
        )
    
    @staticmethod
    def build_context_aware_matching_prompt(template_title: str, template_level: int, 
                                          template_position: int, candidate_chapters: list,
                                          context_info: str = "") -> str:
        """构建上下文感知匹配提示词"""
        # 格式化候选章节
        candidates_section = ""
        for i, chapter in enumerate(candidate_chapters):
            candidates_section += f"候选{i+1}: {chapter.title} (H{chapter.level}, 位置{chapter.position})\n"
        
        return DocumentCheckerPrompts.CONTEXT_AWARE_MATCHING.format(
            template_title=template_title,
            template_level=template_level,
            template_position=template_position + 1,  # 转换为1基索引
            candidate_chapters=candidates_section,
            context_info=context_info
        )
